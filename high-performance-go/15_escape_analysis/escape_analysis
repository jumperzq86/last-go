go语言中，堆内存是通过垃圾回收机制自动管理的，无需开发者指定。
go编译器如何直到某个变量需要分配在栈上还是堆上呢？
编译器决定内存分配位置的方式，就称为逃逸分析。
逃逸分析由编译器完成，作用于编译阶段。

指针逃逸
即函数中创建了一个对象，返回了这个对象的指针。

interface{}动态类型逃逸
如果函数参数为interface{}，编译期间很难确定其参数的具体类型，因此发生逃逸

栈空间不足
对go编译器而言，超过一定大小的局部变量将逃逸到堆上。

闭包
闭包函数访问了外部变量，该变量需要一直存在，直到闭包函数变量被销毁。

利用逃逸分析来提升性能
传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。
传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。
在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

总之，一般情况下，
对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。
对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。